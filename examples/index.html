<!DOCTYPE html>
 <!--[if lte IE 9]>
     <html lang="en" class="isIE9">
 <![endif]-->
 <![if !IE]>
 	<html lang="en">
 <![endif]>
	<head>
		<title>Juniper Holiday Card</title>

		<script src="js/jquery/jquery.js"></script>
		<script src="js/jquery/jquery-ui.js"></script>
		<script src="js/jquery/jquery.ui.touch-punch.min.js"></script>
		<link href="js/jquery/jquery-ui.css" rel="stylesheet">

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			@font-face {
			    font-family: antenna;
			    src: url(fonts/Antenna-Regular.otf);
			}

			body {
				background:#000;
				color:#fff;
				padding:0;
				margin:0;
				overflow:hidden;
				font-family:georgia;
				text-align:center;
			}
			a {	color: #ff0080;	text-decoration: none; }
			a:hover { color: #0080ff; }

			canvas { pointer-events:none; z-index:10; }

			#d { text-align:center; margin:1em auto -9.5em; z-index:200; position:relative; display:block;
				background:rgba(0,0,0,0.5); padding:0.5em; width:400px; border-radius:15px; -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,0.5) }

			#oldie { margin-top:15em !important }

			div#progressbar {
				margin-top: 25%;
				margin-left: 10%;
				width: 80%;
			}

			div#titleslider{
				position: absolute;
				top: 20px;
				right: 5px;
				width: 100px;
				text-align: center;
				z-index : 100;
				color: #fff;
				font-family: antenna;
			}

			div#footerslider{
				position: absolute;
				top: 275px;
				right: 5px;
				width: 100px;
				text-align: center;
				z-index : 100;
				color: #fff;
				font-family: antenna;
			}

			div#slider {
				position: absolute;
				top : 75px;
				right: 50px;
				width: 10px;
				height: 175px;
				z-index : 100;
			}

			div#audio {
				position: absolute;
				top : 0px;
				left: 0px;
			}

			.ui-slider-vertical .ui-state-default {
				background: white url(js/jquery/images/blackSlider.jpg) no-repeat scroll 50% 50%;
				height: 50px;
				color: #000000;
			}

			/** ie specific styles **/
			.video-fallback {
				display: none; /** display none as default, to be shown when is IE **/

				width: 100vw;
				height: 100vh;
				margin: 0;
				padding: 0;
			}

			.isIE10 #slider_container, 
			.isIE10 #progressbar,
			.isIE10 #audio,
			.isIE9 #slider_container, 
			.isIE9 #progressbar,
			.isIE9 #audio {
				display: none;
			}

			.isIE9 .video-fallback,
			.isIE10 .video-fallback {
				display: block;
			}
			
		</style>
		
		<script>
	        // Minified version of isMobile included in the HTML since it's small
	        /*!function(a){var b=/iPhone/i,c=/iPod/i,d=/iPad/i,e=/(?=.*\bAndroid\b)(?=.*\bMobile\b)/i,f=/Android/i,g=/IEMobile/i,h=/(?=.*\bWindows\b)(?=.*\bARM\b)/i,i=/BlackBerry/i,j=/BB10/i,k=/Opera Mini/i,l=/(?=.*\bFirefox\b)(?=.*\bMobile\b)/i,m=new RegExp("(?:Nexus 7|BNTV250|Kindle Fire|Silk|GT-P1000)","i"),n=function(a,b){return a.test(b)},o=function(a){var o=a||navigator.userAgent,p=o.split("[FBAN");return"undefined"!=typeof p[1]&&(o=p[0]),this.apple={phone:n(b,o),ipod:n(c,o),tablet:!n(b,o)&&n(d,o),device:n(b,o)||n(c,o)||n(d,o)},this.android={phone:n(e,o),tablet:!n(e,o)&&n(f,o),device:n(e,o)||n(f,o)},this.windows={phone:n(g,o),tablet:n(h,o),device:n(g,o)||n(h,o)},this.other={blackberry:n(i,o),blackberry10:n(j,o),opera:n(k,o),firefox:n(l,o),device:n(i,o)||n(j,o)||n(k,o)||n(l,o)},this.seven_inch=n(m,o),this.any=this.apple.device||this.android.device||this.windows.device||this.other.device||this.seven_inch,this.phone=this.apple.phone||this.android.phone||this.windows.phone,this.tablet=this.apple.tablet||this.android.tablet||this.windows.tablet,"undefined"==typeof window?this:void 0},p=function(){var a=new o;return a.Class=o,a};"undefined"!=typeof module&&module.exports&&"undefined"==typeof window?module.exports=o:"undefined"!=typeof module&&module.exports&&"undefined"!=typeof window?module.exports=p():"function"==typeof define&&define.amd?define("isMobile",[],a.isMobile=p()):a.isMobile=p()}(this);*/


	        // My own arbitrary use of isMobile, as an example
	        /*(function () {
	            var MOBILE_SITE = 'index_m.html', // site to redirect to
	                NO_REDIRECT = 'noredirect'; // cookie to prevent redirect

	            // I only want to redirect iPhones, Android phones and a handful of 7" devices
	            if (isMobile.any) {

	                // Only redirect if the user didn't previously choose
	                // to explicitly view the full site. This is validated
	                // by checking if a "noredirect" cookie exists
	                if ( document.cookie.indexOf(NO_REDIRECT) === -1 ) {
	                    document.location = MOBILE_SITE;
	                }
	            }
	        })();*/
	    </script>
	</head>

	<body>
		<div id="slider_container">
			<div id="titleslider">Blizzard</div>
			<div id="slider"></div>
			<div id="footerslider">Flurry</div>
		</div>
		<div id="progressbar"></div>
		
		<div id='audio'>
			<!--<embed src="audio/juniper-holiday.mp3" autostart=true loop=true>-->
			<audio loop="loop" autoplay="autoplay" controls="controls"> 
			   <source src="audio/juniper-holiday.mp3" />  
			</audio>
		</div>

		<video class="video-fallback" width="100%" height="auto" autoplay loop>
			<source src="movie.mp4" type="video/mp4">
			Your browser does not support the video tag.
		</video>

		<script src="js/three.min.js"></script>

		<script src="js/loaders/DDSLoader.js"></script>
		<script src="js/loaders/MTLLoader.js"></script>
		<script src="js/loaders/OBJMTLLoader.js"></script>
		<script src="js/loaders/OBJLoader.js"></script>
		<script src="js/SPE.min.js"></script>

		<script src="js/Detector.js"></script>

		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<!--<script src="js/controls/OrbitControls.js"></script>-->
		
		<!-- 3D Text -->
		<script src="js/geometries/TextGeometry.js"></script>
		<script src="js/utils/FontUtils.js"></script>
		<script src="fonts/helvetiker_regular.typeface.js"></script>
		<script src="fonts/Antenna Regular_Regular.js"></script>
		<script src="js/shaders/FresnelShader.js"></script>
		
		<!-- Post Processing files -->
		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/VignetteShader.js"></script>
		

		<script>
			var isMobile;

			var isIE10 = false,
				isIE9 = false;
		    /*@cc_on
		        if (/^10/.test(@_jscript_version)) {
		            isIE10 = true;
		        }
		    @*/
		    if($('html').hasClass('isIE9')) {
		    	isIE9 = true;
		    }
		    // console.log('ie10:  ' + isIE10);
		    // console.log('ie9:  ' + isIE9);

		    if(!isIE9 && !isIE10) {

				//if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

				var FLOOR = -250;
				var SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;
				var clock = new THREE.Clock();

				var container, stats;

				var camera, scene, renderer;
				var controls;
				var cameraCube, sceneCube, cubeTarget, particleScene;

				var emitter, particleGroup;

				var tloader, omloader, objloader, onProgress, onError;

				var directionalLight, pointLight, spotLight, dirLight;

				var windowHalfX = window.innerWidth / 2;
				var windowHalfY = window.innerHeight / 2;

				var mouseDown = false;
				var mouseDownStart, startRotationY, targetRotationY;

				var globeGroup;
				var sunnyvaleGroup, moscowGroup, hongkongGroup, newjerseyGroup, westfordGroup, amsterdamGroup, ukGroup, bangaloreGroup;
				var currentGroup = 0;
				var cityGroups;
				var palmTrees, cLights;

				var raycaster = new THREE.Raycaster();
				var mouse = new THREE.Vector2();
				var INTERSECTED;
				var raycastObjects;
				var onClickFunctions;

				var sunnyvaleToggle = false;
				var bangaloreToggle = false;
				var hongkongToggle = false;
				var newjerseyToggle = false;
				var westfordToggle = false;
				var amsterdamToggle = false;
				var ukToggle = false;
				var bangaloreToggle = false;

				var loaded = false;
				var startRotation = false;

				var composer;



				
				$(function(){
					$("#slider_container").hide();
					$("#audio").hide();
				});

				$(function() {
					$( "#progressbar" ).progressbar({
						value: 0
					}).ready( function () {
						console.log ("done progress bar");
						init ();
						animate();
					});
				});

				$(function() {
					$( "#slider" ).slider({
						min: 1,
						max: 100,
						value: 1,
						orientation: "vertical",
						start: function( event, ui ) {
							emitter.activeMultiplier = (ui.value / 100);
							mouseDown = false;
						},
						slide: function( event, ui ) {
							emitter.activeMultiplier = (ui.value / 100);
							mouseDown = false;
						}
					});
				});

				//init();
				//animate();
				

				function init() {
					// Minified version of isMobile included in the HTML since it's small
		        	!function(a){var b=/iPhone/i,c=/iPod/i,d=/iPad/i,e=/(?=.*\bAndroid\b)(?=.*\bMobile\b)/i,f=/Android/i,g=/IEMobile/i,h=/(?=.*\bWindows\b)(?=.*\bARM\b)/i,i=/BlackBerry/i,j=/BB10/i,k=/Opera Mini/i,l=/(?=.*\bFirefox\b)(?=.*\bMobile\b)/i,m=new RegExp("(?:Nexus 7|BNTV250|Kindle Fire|Silk|GT-P1000)","i"),n=function(a,b){return a.test(b)},o=function(a){var o=a||navigator.userAgent,p=o.split("[FBAN");return"undefined"!=typeof p[1]&&(o=p[0]),this.apple={phone:n(b,o),ipod:n(c,o),tablet:!n(b,o)&&n(d,o),device:n(b,o)||n(c,o)||n(d,o)},this.android={phone:n(e,o),tablet:!n(e,o)&&n(f,o),device:n(e,o)||n(f,o)},this.windows={phone:n(g,o),tablet:n(h,o),device:n(g,o)||n(h,o)},this.other={blackberry:n(i,o),blackberry10:n(j,o),opera:n(k,o),firefox:n(l,o),device:n(i,o)||n(j,o)||n(k,o)||n(l,o)},this.seven_inch=n(m,o),this.any=this.apple.device||this.android.device||this.windows.device||this.other.device||this.seven_inch,this.phone=this.apple.phone||this.android.phone||this.windows.phone,this.tablet=this.apple.tablet||this.android.tablet||this.windows.tablet,"undefined"==typeof window?this:void 0},p=function(){var a=new o;return a.Class=o,a};"undefined"!=typeof module&&module.exports&&"undefined"==typeof window?module.exports=o:"undefined"!=typeof module&&module.exports&&"undefined"!=typeof window?module.exports=p():"function"==typeof define&&define.amd?define("isMobile",[],a.isMobile=p()):a.isMobile=p()}(this);

					container = document.createElement('div');
					document.body.appendChild(container);

					camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100000 );
					//var camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000 );
					camera.position.z = 400;
					camera.position.y = 50;

					cameraCube = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100000 );

					loadingScene = new THREE.Scene();
					scene = new THREE.Scene();
					sceneCube = new THREE.Scene();
					particleScene = new THREE.Scene();

					scene.visible = false;
					sceneCube.visible = false;
					particleScene.visible = false;

					// LIGHTS
					var ambient = new THREE.AmbientLight( 0x999999, 0.1 );
					scene.add( ambient );

					dirLight = new THREE.DirectionalLight( 0xffffff, 0.25 );
					dirLight.color.setHSL( 0.1, 1, 0.95 );
					dirLight.position.set( -0.25, 1, 0.25 );
					dirLight.position.multiplyScalar( 50 );
					scene.add( dirLight );

					// Enable/Disable shadow casting.
					//dirLight.castShadow = true;

					var dbox = new THREE.BoxGeometry( 10, 10, 10 );
					var dmesh = new THREE.Mesh( dbox, new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
					//dmesh.scale.set( , 0.05, 0.05 );
					//dirLight.add( dmesh );

					pointLight = new THREE.PointLight( 0xffffff, 0.9 );
					pointLight.position.set (-250, 500, 500);
					scene.add( pointLight );

					// light representation
					//var sphere = new THREE.SphereGeometry( 100, 16, 8 );
					//var mesh = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
					//mesh.scale.set( 0.05, 0.05, 0.05 );
					//pointLight.add( mesh );

					// material samples
					var r = "textures/cube/gray2/";

					/*var urls = [ r + "px.jpg", r + "nx.jpg",
								 r + "py.jpg", r + "ny.jpg",
								 r + "pz.jpg", r + "nz.jpg" ];*/
					 var urls = [ r + "nx.jpg", r + "nx.jpg",
								 r + "ny.jpg", r + "ny.jpg",
								 r + "nx.jpg", r + "nx.jpg" ];

					var textureCube = THREE.ImageUtils.loadTextureCube( urls, THREE.CubeRefractionMapping );

					// Skybox
					var shader = THREE.ShaderLib[ "cube" ];
					shader.uniforms[ "tCube" ].value = textureCube;

					var material = new THREE.ShaderMaterial( {

						fragmentShader: shader.fragmentShader,
						vertexShader: shader.vertexShader,
						uniforms: shader.uniforms,
						side: THREE.BackSide

					} ),

					mesh = new THREE.Mesh( new THREE.BoxGeometry( 100000, 100000, 100000 ), material );
					sceneCube.add( mesh );

					// Renderer
					renderer = new THREE.WebGLRenderer( { antialias: true } );

					// No autoClear for vignetting.
					//if (!isMobile.any)
						renderer.autoClear = false;

					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( window.innerWidth, window.innerHeight );
					container.appendChild( renderer.domElement );

					//renderer.shadowMap.enabled = true;
					//renderer.shadowMapType = THREE.PCFSoftShadowMap;


					// GUI Stats
					/*stats = new Stats();
					stats.domElement.style.position = 'absolute';
					stats.domElement.style.bottom = '0px';
					stats.domElement.style.zIndex = 100;
					container.appendChild( stats.domElement );*/


					// Setup loaders.
					onProgress = function ( xhr ) {
						if ( xhr.lengthComputable ) {
							var percentComplete = xhr.loaded / xhr.total * 100;
							console.log( Math.round(percentComplete, 2) + '% downloaded' );
						}
					};

					onError = function ( xhr ) {
					};

					THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );

					omloader = new THREE.OBJMTLLoader();
					tloader = new THREE.TextureLoader();
					objloader = new THREE.OBJLoader();

					THREE.DefaultLoadingManager.onLoad = function ( ) {
					    console.log( "all done" );
					    $('#progressbar').hide();
					    $('#slider_container').show();
					    startRotation = true;
					    scene.visible = true;
						sceneCube.visible = true;
						particleScene.visible = true;
					};

					THREE.DefaultLoadingManager.onProgress = function ( item, loaded, total ) {
						console.log( item, loaded, total );
						$( "#progressbar" ).progressbar( "option", "value", (loaded / total) * 100);
						//console.log ($( "#progressbar" ).progressbar( "option", "value" ));
					};

					/////////////////
					// GLOBE GROUP //
					/////////////////

					// Group all the snowglobe elements together.
					// The globeGroup contains all cityGroups so that they can be rotated together.
					// Each cityGroup will have its visiblity toggled based on rotation.
					globeGroup = new THREE.Group();

					if (!isMobile.any){
						// Back side reflective material.
						var fshader = THREE.FresnelShader;
						var funiforms = THREE.UniformsUtils.clone( fshader.uniforms );
						funiforms[ "tCube" ].value = textureCube;
						var fparameters = { fragmentShader: fshader.fragmentShader, vertexShader: fshader.vertexShader, uniforms: funiforms, side: THREE.BackSide };
						var sphereMaterial0 = new THREE.ShaderMaterial( fparameters );

						var sphereGeometry0 = new THREE.SphereBufferGeometry( 100, 64, 64 );
						//var sphereMaterial0 = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube, reflectivity:1, transparent: true, opacity: 0.25 } );
						var sphereMesh0 = new THREE.Mesh( sphereGeometry0, sphereMaterial0 );
						globeGroup.add( sphereMesh0 );

						// Front side reflective material.
						var sphereGeometry1 = new THREE.SphereBufferGeometry( 100, 64, 64 );
						var sphereMaterial1 = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube, reflectivity: 0.9, transparent: true, opacity: 0.2 } );
						var sphereMesh1 = new THREE.Mesh( sphereGeometry1, sphereMaterial1 );
						globeGroup.add( sphereMesh1 );
					}
					
					// Back side secondary material.
					var sphereGeometry2 = new THREE.SphereBufferGeometry( 98, 64, 64 );
					var sphereMaterial2 = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube, refractionRatio: 0.98, side: THREE.BackSide } );
					var sphereMesh2 = new THREE.Mesh( sphereGeometry2, sphereMaterial2 );
					globeGroup.add( sphereMesh2 );

					// Load base model.
					omloader.load( 'obj/snowglobe/Base2.obj', 'obj/snowglobe/Base2.mtl', function ( object ) {
						var texture = THREE.ImageUtils.loadTexture('obj/snowglobe/Base_Diffuse_SQUARE_g.jpg');
						texture.generateMipmaps = false;
						texture.magFilter = THREE.LinearFilter;
						texture.minFilter = THREE.LinearFilter;


						object.traverse(function(child) {
						    if(child instanceof THREE.Mesh) {
						      	//console.log(child.material);
								child.material = new THREE.MeshPhongMaterial ( {
									//map: child.material.map,
									//color: child.material.color,
									map: texture,
									color: child.material.color,
									shininess: 20,
									blending: THREE.SmoothShading
								});
								//child.castShadow = true;
								//child.receiveShadow = true;
						    }
						});
						object.scale.set (50, 50, 50);
						object.position.set (0, -83, 0);
						object.rotation.set (0, Math.PI, 0);

						globeGroup.add( object );
					}, onProgress, onError );

					// Load trees model.
					omloader.load( 'obj/snowglobe/trees.obj', 'obj/snowglobe/trees.mtl', function ( object ) {
						//var texture = THREE.ImageUtils.loadTexture('obj/snowglobe/baseNoLipColor.jpg');
						object.traverse(function(child) {
						    if(child instanceof THREE.Mesh) {
						      	//console.log(child.material);
								child.material = new THREE.MeshPhongMaterial ( {
									map: child.material.map,
									color: child.material.color,
									//map: texture,
									//color: child.material.color,
									shininess: 20,
									blending: THREE.SmoothShading
								});
								child.castShadow = true;
								child.receiveShadow = true;
						    }
						});
						object.scale.set (50, 50, 50);
						object.position.set (0, -83, 0);
						object.rotation.set (0, Math.PI, 0);

						globeGroup.add( object );
					}, onProgress, onError );


					// Load back panel for all images in globe group.
					var backGeometry = new THREE.CylinderGeometry( 95, 95, 1, 64 );
					var backMaterial = new THREE.MeshBasicMaterial( { color: 0xeeeeee } );
					var backPlane = new THREE.Mesh( backGeometry, backMaterial );
					backPlane.position.set (0, 0, -1);
					backPlane.rotation.set (Math.PI/2, 0, 0);
					//backPlane.castShadow = true;
					globeGroup.add( backPlane );

					tloader.load( 'textures/juniper-logo.png', function ( texture ) {
						var material = new THREE.MeshBasicMaterial( {
							map: texture,
							alphaTest: 0.5
						} );
						var geometry = new THREE.CircleGeometry (70, 64);
						var plane = new THREE.Mesh( geometry, material );
						plane.rotation.set (0, Math.PI, 0);
						plane.position.set (0, 0, -2);
						globeGroup.add( plane );
					}, onProgress, onError);


					// Ground Plane shadow.
					/*groundGeo = new THREE.CircleGeometry( 110, 64 );
					var groundMat = new THREE.MeshBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.1 } );
					var groundMesh = new THREE.Mesh( groundGeo, groundMat );
					groundMesh.rotation.set (-Math.PI/2, 0, 0);
					groundMesh.position.set (15, -105, 5);
					//groundMesh.receiveShadow = true;
					scene.add( groundMesh );*/
					tloader.load( 'textures/PlainBase_Shadow.JPG', function ( texture ) {
						groundGeo = new THREE.PlaneGeometry( 570, 570 );
						var groundMat = new THREE.MeshBasicMaterial( { map: texture } );
						var groundMesh = new THREE.Mesh( groundGeo, groundMat );
						groundMesh.rotation.set (-Math.PI/2, 0, Math.PI);
						groundMesh.position.set (0, -100, -6);
						scene.add( groundMesh );
					}, onProgress, onError);


					///////////////
					// SUNNYVALE //
					///////////////
					sunnyvaleGroup = new THREE.Group();
					createImage ('textures/locations/sunnyvale.jpg', sunnyvaleGroup);
					createSign ("textures/locations/titles/sunnyvale_t.jpg", sunnyvaleGroup);
					globeGroup.add (sunnyvaleGroup);

					////////////
					// MOSCOW //
					////////////
					moscowGroup = new THREE.Group();
					createImage ('textures/locations/moscow.jpg', moscowGroup);
					createSign ("textures/locations/titles/moscow_t.jpg", moscowGroup);
					globeGroup.add (moscowGroup);

					/////////////
					// DENMARK //
					/////////////
					hongkongGroup = new THREE.Group();
					createImage ('textures/locations/hongkong.jpg', hongkongGroup);
					createSign ("textures/locations/titles/hongkong_t.jpg", hongkongGroup);
					globeGroup.add (hongkongGroup);

					////////////////
					// NEW JERSEY //
					////////////////
					newjerseyGroup = new THREE.Group();
					createImage ('textures/locations/newjersey.jpg', newjerseyGroup);
					createSign ("textures/locations/titles/newjersey_t.jpg", newjerseyGroup);
					globeGroup.add (newjerseyGroup);

					//////////////
					// WESTFORD //
					//////////////
					westfordGroup = new THREE.Group();
					createImage ('textures/locations/westford.jpg', westfordGroup);
					createSign ("textures/locations/titles/westford_t.jpg", westfordGroup);
					globeGroup.add (westfordGroup);

					///////////////
					// AMSTERDAM //
					///////////////
					amsterdamGroup = new THREE.Group();
					createImage ('textures/locations/amsterdam.png', amsterdamGroup);
					createSign ("textures/locations/titles/amsterdam_t.jpg", amsterdamGroup);
					globeGroup.add (amsterdamGroup);

					////////
					// UK //
					////////
					ukGroup = new THREE.Group();
					createImage ('textures/locations/uk.jpg', ukGroup);
					createSign ("textures/locations/titles/addlestone_t.jpg", ukGroup);
					globeGroup.add (ukGroup);

					///////////////
					// BANGALORE //
					///////////////
					bangaloreGroup = new THREE.Group();
					createImage ('textures/locations/bangalore.jpg', bangaloreGroup);
					createSign ("textures/locations/titles/bangalore_t.jpg", bangaloreGroup);
					globeGroup.add (bangaloreGroup);


					// Add city groups to scene.
					cityGroups = [ sunnyvaleGroup, moscowGroup, hongkongGroup, newjerseyGroup, westfordGroup, amsterdamGroup, ukGroup, bangaloreGroup ];
					moscowGroup.visible = false;
					hongkongGroup.visible = false;
					newjerseyGroup.visible = false;
					westfordGroup.visible = false;
					amsterdamGroup.visible = false;
					ukGroup.visible = false;
					bangaloreGroup.visible = false;

					globeGroup.rotation.y = -0.001;
					scene.add (globeGroup);



					/////////////////////
					// Raycast Objects //
					/////////////////////
					raycastObjects = [];
					createRaycastObject (
						"sunnyvale",
						new THREE.Vector3( 40, 40, 20 ), 
						sunnyvaleGroup 
					);

					createRaycastObject (
						"bangalore",
						new THREE.Vector3( 10, 10, 20 ), 
						bangaloreGroup 
					);

					createRaycastObject (
						"hongkong",
						new THREE.Vector3( -20, -10, 20 ), 
						hongkongGroup 
					);

					createRaycastObject (
						"newjersey",
						new THREE.Vector3( -30, 30, 20 ), 
						newjerseyGroup 
					);

					createRaycastObject (
						"uk",
						new THREE.Vector3( -10, 40, 20 ), 
						ukGroup 
					);


					// Load palm trees.
					palmTrees = new THREE.Group();
					omloader.load( 'obj/snowglobe/MY_PALM.obj', 'obj/snowglobe/MY_PALM.mtl', function ( object ) {
						var texture = THREE.ImageUtils.loadTexture('obj/snowglobe/palm1_uv_m2.bmp');
						object.traverse(function(child) {
						    if(child instanceof THREE.Mesh) {
						      	//console.log(child.material);
								child.material = new THREE.MeshLambertMaterial ( {
									map: texture,
									//color: child.material.color,
									//shininess: 20,
									//blending: THREE.SmoothShading
								});
								//child.castShadow = true;
								//child.receiveShadow = true;
						    }
						});
						object.scale.set (0.05, 0.05, 0.05);
						object.position.set (-20, -60, 10);
						object.rotation.set (0, Math.PI, 0);
						palmTrees.add( object );

						/*var tree0 = object.clone();
						tree0.scale.set (0.05, 0.05, 0.05);
						tree0.position.set (-40, -60, -30);
						tree0.rotation.set (0, -Math.PI / 2, 0);
						palmTrees.add( tree0 );*/

						var tree1 = object.clone();
						tree1.scale.set (0.045, 0.045, 0.045);
						tree1.position.set (-40, -60, 30);
						tree1.rotation.set (0, Math.PI / 2, 0);
						palmTrees.add( tree1 );

						var tree2 = object.clone();
						tree2.scale.set (0.04, 0.04, 0.04);
						tree2.position.set (0, -60, 10);
						tree2.rotation.set (0, 0, 0);
						palmTrees.add( tree2 );

						var tree3 = object.clone();
						tree3.scale.set (0.04, 0.04, 0.04);
						tree3.position.set (40, -60, 20);
						tree3.rotation.set (0, Math.PI / 3, 0);
						palmTrees.add( tree3 );

					}, onProgress, onError );
					palmTrees.visible = false;
					sunnyvaleGroup.add (palmTrees);


					// Create christmas lights.
					cLights = new THREE.Group();
					rLights = new THREE.Group();
					gLights = new THREE.Group();

					var cLightGeo = new THREE.SphereGeometry (1, 8, 8);
					var cLightMatRed = new THREE.MeshBasicMaterial ( { color: 0xff0000 } );
					var cLightMeshRed = new THREE.Mesh (cLightGeo, cLightMatRed);
					cLightMeshRed.position.set ( 40, -37, 61 );
					rLights.add (cLightMeshRed);

					for ( var i = 0; i < 8; i++){
						var cLight = cLightMeshRed.clone();
						cLight.position.set (-40 + (10 * i), -37, 61);
						rLights.add (cLight);
					}

					var cLightR0 = cLightMeshRed.clone ();
					cLightR0.position.set ( -15, -45, 28.5 );
					rLights.add (cLightR0);

					var cLightR1 = cLightMeshRed.clone ();
					cLightR1.position.set ( -37, -35, 17 );
					rLights.add (cLightR1);

					var cLightR2 = cLightMeshRed.clone ();
					cLightR2.position.set ( -31, -43, 35 );
					rLights.add (cLightR2);

					var cLightMatGreen = new THREE.MeshBasicMaterial ( { color: 0x00ff00 } );
					var cLightMeshGreen = new THREE.Mesh (cLightGeo, cLightMatGreen);
					cLightMeshGreen.position.set ( 35, -37, 61 );
					gLights.add (cLightMeshGreen);

					for ( var i = 0; i < 7; i++){
						var cLight = cLightMeshGreen.clone();
						cLight.position.set (-35 + (10 * i), -37, 61);
						gLights.add (cLight);
					}

					var cLightG0 = cLightMeshGreen.clone ();
					cLightG0.position.set ( 33, -40, 17 );
					gLights.add (cLightG0);

					var cLightG1 = cLightMeshGreen.clone ();
					cLightG1.position.set ( -33, -35, 34 );
					gLights.add (cLightG1);

					var cLightG2 = cLightMeshGreen.clone ();
					cLightG2.position.set ( -43, -40, 24 );
					gLights.add (cLightG2);

					cLights.add (rLights);
					cLights.add (gLights);
					cLights.visible = false;
					newjerseyGroup.add (cLights);


					// Holiday point lights and meshes.
					//pointLight = new THREE.PointLight( 0xffffff, 2 );
					//scene.add( pointLight );

					// Snowman
					snowmanGroup = new THREE.Group();
					var snowmanGeo = new THREE.SphereGeometry (10, 16, 16);
					var snowmanMaterial = new THREE.MeshLambertMaterial( {color: 0xffffff} );

					var snowmanBase = new THREE.Mesh( snowmanGeo, snowmanMaterial );
					snowmanBase.position.set ( 10, -50, 30 );
					snowmanGroup.add (snowmanBase);

					var snowmanMid = new THREE.Mesh( snowmanGeo, snowmanMaterial );
					snowmanMid.scale.set (0.7, 0.7, 0.7);
					snowmanMid.position.set ( 10, -40, 30 );
					snowmanGroup.add (snowmanMid);

					var snowmanHead = new THREE.Mesh( snowmanGeo, snowmanMaterial );
					snowmanHead.scale.set (0.5, 0.5, 0.5);
					snowmanHead.position.set ( 10, -30, 30 );
					snowmanGroup.add (snowmanHead);

					var buttonGeo = new THREE.SphereGeometry (1, 8, 8);
					var buttonMaterial = new THREE.MeshLambertMaterial( {color: 0x000000} );

					var eye_l = new THREE.Mesh( buttonGeo, buttonMaterial );
					eye_l.position.set ( 8, -30, 34 );
					snowmanGroup.add (eye_l);

					var eye_r = new THREE.Mesh( buttonGeo, buttonMaterial );
					eye_r.position.set ( 12, -30, 34 );
					snowmanGroup.add (eye_r);

					var hatGeo = new THREE.CylinderGeometry( 5, 5, 5, 5, 1, true );
					var hatMaterial = new THREE.MeshLambertMaterial( {
						color: 0x009999,
						side: THREE.DoubleSide
					} );
					var hatMesh = new THREE.Mesh( hatGeo, hatMaterial );
					hatMesh.position.set ( 10, -25, 30 );
					snowmanGroup.add( hatMesh );

					ukGroup.add (snowmanGroup);
					snowmanGroup.visible = false;


					// Functionality of each onClick action for raycasts.
					onClickFunctions = {
						'sunnyvale' : function () { 
							if (!sunnyvaleToggle)
								palmTrees.visible = true;
							else
								palmTrees.visible = false;

							sunnyvaleToggle = !sunnyvaleToggle;
						},

						'bangalore' : function (){
							if (!bangaloreToggle) {
								emitter.color.value = [ new THREE.Color('red'), new THREE.Color('green'), new THREE.Color('blue') ]; 
								emitter.size.value = [ 1, 30, 0 ];
							} else {
								emitter.size.value = [ 1, 10, 0 ];
								emitter.color.value = [ new THREE.Color('white') ]; 
							}

							bangaloreToggle = !bangaloreToggle;
						},

						'hongkong' : function (){
							if (!hongkongToggle)
								emitter.direction = -1;
							else
								emitter.direction = 1;

							hongkongToggle = !hongkongToggle;
						},

						'newjersey' : function (){
							if (!newjerseyToggle) {
								cLights.visible = true;
							} else {
								cLights.visible = false;
							}
							newjerseyToggle = !newjerseyToggle;
						},

						'uk' : function (){
							if (!ukToggle) {
								snowmanGroup.visible = true;
							} else {
								snowmanGroup.visible = false;
							}
							ukToggle = !ukToggle;
						}
					};


					// Initialize particle emitters.
					initParticles('textures/sprites/snowflake2.png');


					// GUI
					/*var snowConfig = { snowLevel: 0.1 };
					var gui = new dat.GUI();
					var snowGUI = gui.addFolder( "Snow Level" );
					snowGUI.add( snowConfig, 'snowLevel', 0.1, 1 ).onChange( function() {
						emitter.activeMultiplier = snowConfig.snowLevel;
						mouseDown = false;
					});
					snowGUI.open();*/

					//

					document.addEventListener( 'mousemove', onDocumentMouseMove, false);
					document.addEventListener( 'mousedown', onDocumentMouseDown, false);
					document.addEventListener( 'mouseup', onDocumentMouseUp, false);
					document.addEventListener( 'touchstart', touchstart, false );
					document.addEventListener( 'touchmove', touchmove, false );
					document.addEventListener( 'touchend', touchend, false);

					//

					window.addEventListener( 'resize', onWindowResize, false );

					if (!isMobile.any)
						setupComposer();

				}


				function setupComposer (){
					var rtParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: true };

					composer = new THREE.EffectComposer( renderer );

					var renderBackground = new THREE.RenderPass( sceneCube, cameraCube );
					composer.addPass (renderBackground);

					var renderModel = new THREE.RenderPass( scene, camera );
					renderModel.clear = false;
					composer.addPass (renderModel);

					var shaderVignette = THREE.VignetteShader;
					var effectVignette = new THREE.ShaderPass( shaderVignette );
					// larger values = darker closer to center
					// darkness < 1  => lighter edges
					effectVignette.uniforms[ "offset" ].value = 1.1;
					effectVignette.uniforms[ "darkness" ].value = 1.6;
					effectVignette.renderToScreen = true;
					composer.addPass ( effectVignette );
					
				}


				function createRaycastObject ( name, position, group ){
					var rayGeo = new THREE.IcosahedronGeometry( 10, 0 );
					var rayMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } );
					var rayMesh = new THREE.Mesh( rayGeo, rayMaterial );
					rayMesh.name = name;
					rayMesh.position.set (position.x, position.y, position.z);
					group.add ( rayMesh );
					raycastObjects.push ( rayMesh );
				}


				function createImage ( url, group ){
					tloader.load( url, function ( texture ) {
						var material = new THREE.MeshBasicMaterial( {
							map: texture
						} );
						var geometry = new THREE.CircleGeometry (95, 64);
						var plane = new THREE.Mesh( geometry, material );
						plane.position.set (0, 0, 0);
						group.add( plane );
					}, onProgress, onError);
				}


				function createSign ( url, group ){
					// Create sign box.
					tloader.load( url, function ( texture ) {
						// Prevent texture generation.
						texture.generateMipmaps = false;
						texture.magFilter = THREE.LinearFilter;
						texture.minFilter = THREE.LinearFilter;

						// Generate geometry and material from texture url.
						var geometry = new THREE.BoxGeometry( 80, 20, 1 );
						var material = new THREE.MeshBasicMaterial( { color: 0xeeeeee, map: texture } );
						var mesh = new THREE.Mesh( geometry, material );
						mesh.position.set (0, -47, 60);
						mesh.castShadow = true;
						group.add( mesh );
					});
				}


				// Create particle group and emitter
		        function initParticles( url ) {
		        	var maxCount;
		        	var pCount;
		        	var mult;

		        	if (isMobile.any) {
		        		maxCount = 2000;
		        		pCount = 2000;
		        		mult = 0.1;
		        	} else {
		        		maxCount = 20000;
		        		pCount = 20000;
		        		mult = 0.01;
		        	}
		        	
					particleGroup = new SPE.Group({
		        		texture: {
		                    value: THREE.ImageUtils.loadTexture(url)
		                },
		                maxParticleCount: maxCount
		        	});

		        	emitter = new SPE.Emitter({
		                maxAge: {
		                    value: 1
		                },

		        		position: {
		                    value: new THREE.Vector3(0, 10, 0),
		                    radius: 90,
		                    spread: 100,
		                    distribution: SPE.distributions.SPHERE
		                },

		        		acceleration: {
		                    value: new THREE.Vector3(0, 25, 0),
		                    spread: new THREE.Vector3( 5, 5, 5 )
		                },

		        		velocity: {
		                    value: new THREE.Vector3(0, -50, 0),
		                },

		                color: {
		                    value: [ new THREE.Color('white') ]
		                },

		                size: {
		                    value: [ 1, 10, 0 ],
		                    spread: 5
		                },

		        		particleCount: pCount,
		        		activeMultiplier: mult
		        	});

		        	particleGroup.addEmitter( emitter );
		        	particleScene.add( particleGroup.mesh );

		        	var tgeo = new THREE.CylinderGeometry (100, 100, 30);
		        	var tMaterial = new THREE.MeshBasicMaterial ( { transparent: true, opacity: 0 } );
		        	var tMesh = new THREE.Mesh (tgeo, tMaterial);
		        	tMesh.position.set (0, -70, 0);
		        	particleScene.add(tMesh);
		        }


				function onWindowResize() {

					windowHalfX = window.innerWidth / 2,
					windowHalfY = window.innerHeight / 2,

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					cameraCube.aspect = window.innerWidth / window.innerHeight;
					cameraCube.updateProjectionMatrix();
					
					if (composer)
						composer.setSize( window.innerWidth, window.innerHeight );

					renderer.setSize( window.innerWidth, window.innerHeight );

				}


				function onDocumentMouseMove ( event ) {
					event.preventDefault();
					// calculate mouse position in normalized device coordinates
					// (-1 to +1) for both components
					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

					// Find intersecting items from mouse raycast.
					raycaster.setFromCamera( mouse, camera );
					var intersects = raycaster.intersectObjects( raycastObjects );
					if ( intersects.length > 0 ) {
						if (INTERSECTED != intersects[0].object && INTERSECTED){
							INTERSECTED.scale.set ( 1, 1, 1 );
							INTERSECTED.material.wireframe = true;
						}
						INTERSECTED = intersects [0].object;
						intersects [0].object.scale.set ( 1.5, 1.5, 1.5 );
						intersects [0].object.material.wireframe = false;
					} else {
						if (INTERSECTED) {
							INTERSECTED.scale.set ( 1, 1, 1 );
							INTERSECTED.material.wireframe = true;
							INTERSECTED = null;
						}
					}

					// Set new target rotation.
					targetRotationY = startRotationY + ( mouse.x - mouseDownStart ) * 5;
				}

				function onDocumentMouseDown ( event ) {
					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
					mouseDown = true;
					mouseDownStart = mouse.x;
					startRotationY = globeGroup.rotation.y;
					targetRotationY = startRotationY + ( mouse.x - mouseDownStart ) * 5;

					if (INTERSECTED) {
						console.log (INTERSECTED.name);
						onClickFunctions[INTERSECTED.name]();
					}
				}

				function onDocumentMouseUp ( event ) {
					mouseDown = false;
				}



				// Touch mobile events.
				function touchmove ( event ) {
					if (event.touches.length == 1){
						event.preventDefault();
						// calculate mouse position in normalized device coordinates
						// (-1 to +1) for both components

						//mouse.x = ( event.touches[0].pageX / window.innerWidth ) * 2 - 1;
						//mouse.y = - ( event.touches[0].pageY / window.innerHeight ) * 2 + 1;
						mouse.x = event.touches[ 0 ].pageX - windowHalfX;
						mouse.y = event.touches[ 0 ].pageY - windowHalfY;

						// Set new target rotation.
						targetRotationY = startRotationY + ( mouse.x - mouseDownStart ) * 0.05;
					}
				}

				function touchstart ( event ) {
					if (event.touches.length == 1){
						mouse.x = event.touches[ 0 ].pageX - windowHalfX;
						mouse.y = event.touches[ 0 ].pageY - windowHalfY;
						var mx = (event.targetTouches[0].pageX / window.innerWidth) * 2 - 1;
						var my = -(event.targetTouches[0].pageY / window.innerHeight) * 2 + 1;

						mouseDown = true;
						mouseDownStart = event.touches[ 0 ].pageX - windowHalfX;
						startRotationY = globeGroup.rotation.y;
						targetRotationY = startRotationY + ( mouse.x - mouseDownStart ) * 0.05;

						// Raycast to see if selected object.
						raycaster.setFromCamera( new THREE.Vector2 (mx, my), camera );
						var intersects = raycaster.intersectObjects( raycastObjects );
						if ( intersects.length > 0 ) {
							if (INTERSECTED != intersects[0].object && INTERSECTED){
								INTERSECTED.scale.set ( 1, 1, 1 );
								INTERSECTED.material.wireframe = true;
							}
							INTERSECTED = intersects [0].object;
							intersects [0].object.scale.set ( 1.5, 1.5, 1.5 );
							intersects [0].object.material.wireframe = false;
						} else {
							if (INTERSECTED) {
								INTERSECTED.scale.set ( 1, 1, 1 );
								INTERSECTED.material.wireframe = true;
								INTERSECTED = null;
							}
						}
						
						// Activate the object selected.
						if (INTERSECTED) {
							console.log (INTERSECTED.name);
							onClickFunctions[INTERSECTED.name]();
						}
					}
				}

				function touchend ( event ) {
					mouseDown = false;
				}

				//

				function animate() {

					requestAnimationFrame( animate );

					//controls.update();

					render();
					//stats.update();
					

				}

				function render() {
					particleGroup.tick( );

					var dt = clock.getDelta();

					var timer = -0.0002 * Date.now();

					// Clamp the rotation of the globe.
					if (mouseDown){
						globeGroup.rotation.y = targetRotationY;
					}
					else {
						// Rotate automatically.
						if (startRotation)
							globeGroup.rotation.y -= dt * 0.25;
					}

					// Reset rotation if rotation is past Math.PI or -Math.PI * 15.
					if (globeGroup.rotation.y > Math.PI) {
						globeGroup.rotation.y = -Math.PI * 15 + 0.001;
						mouseDownStart = mouse.x;
						startRotationY = globeGroup.rotation.y;
					}

					if (globeGroup.rotation.y < -Math.PI * 15) {
						globeGroup.rotation.y = Math.PI - 0.001;
						mouseDownStart = mouse.x;
						startRotationY = globeGroup.rotation.y;
					}

					// Swap the visibility of the objects depending on the rotation.
					var floorRotation = Math.abs (Math.floor( (globeGroup.rotation.y - Math.PI) / (Math.PI * 2) )) - 1;

					if (floorRotation != currentGroup) {
						for (var i = 0; i < cityGroups.length; i++){
							cityGroups[i].visible = false;
						}
						cityGroups[floorRotation].visible = true;
						currentGroup = floorRotation;
					}

					// Animate the rotations of the raycast items.
					for (var i = 0; i < raycastObjects.length; i++){
						raycastObjects[i].rotation.x += 0.01;
						raycastObjects[i].rotation.y += 0.01;
						raycastObjects[i].rotation.z += 0.01;
					}

					//console.log (Math.sin(Date.now() * 0.0002));

					// Animate lights.
					var rsin = Math.sin(Date.now() * 0.02);
					var rcos = Math.cos(Date.now() * 0.02);
					rLights.traverse(function(child){
						if(child instanceof THREE.Mesh) {
							child.material.color = new THREE.Color( 1, rsin, rsin );
						}
					});
					gLights.traverse(function(child){
						if(child instanceof THREE.Mesh) {
							child.material.color = new THREE.Color( rcos, 1, rcos);
						}
					});


					// Camera
					camera.lookAt( scene.position );
					cameraCube.rotation.copy( camera.rotation );

					renderer.clear();

					if (!composer) {
						renderer.render( sceneCube, cameraCube );
						renderer.render( scene, camera );
					} else {
						composer.render();
					}

					renderer.clearDepth(); // optional, depending on use case
					renderer.render( particleScene, camera );
				}
			} else {
				if(isIE10) {
					$('html').addClass('isIE10');
				}

			}

		</script>

	</body>
</html>
